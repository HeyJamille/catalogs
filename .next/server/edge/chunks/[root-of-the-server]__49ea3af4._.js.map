{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/utils/checkRule.ts"],"sourcesContent":["export enum RegraUsuario {\r\n  admin = \"admin\",\r\n  dono = \"dono\",\r\n  estoque = \"estoque\",\r\n  suportedosistema = \"suporte do sistema\",\r\n  cliente = \"cliente\",\r\n}\r\n\r\n// Check if the user has special permission  (admin, dono, suporte)\r\nexport function checkRule(regra: RegraUsuario): boolean {\r\n  const permissoesEspeciais = new Set([\r\n    RegraUsuario.admin,\r\n    RegraUsuario.dono,\r\n    RegraUsuario.suportedosistema,\r\n  ]);\r\n\r\n  return permissoesEspeciais.has(regra);\r\n}\r\n\r\n// Check if the user is a client\r\nexport function isCliente(regra: RegraUsuario): boolean {\r\n  return regra === RegraUsuario.cliente;\r\n}\r\n\r\n// Check if the user can access a route in the rule and path\r\nexport function podeAcessarRota(regra: RegraUsuario, path: string): boolean {\r\n  if (checkRule(regra)) {\r\n    return true;\r\n  }\r\n\r\n  if (isCliente(regra)) {\r\n    const permitido = path.startsWith(\"/catalogo\");\r\n    return permitido;\r\n  }\r\n\r\n  return false;\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAO,IAAA,AAAK,sCAAA;;;;;;WAAA;;AASL,SAAS,UAAU,KAAmB;IAC3C,MAAM,sBAAsB,IAAI,IAAI;;;;KAInC;IAED,OAAO,oBAAoB,GAAG,CAAC;AACjC;AAGO,SAAS,UAAU,KAAmB;IAC3C,OAAO;AACT;AAGO,SAAS,gBAAgB,KAAmB,EAAE,IAAY;IAC/D,IAAI,UAAU,QAAQ;QACpB,OAAO;IACT;IAEA,IAAI,UAAU,QAAQ;QACpB,MAAM,YAAY,KAAK,UAAU,CAAC;QAClC,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/provider/auth.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const AuthContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call AuthContext() from the server but AuthContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/provider/auth.tsx <module evaluation>\",\n    \"AuthContext\",\n);\nexport const AuthProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call AuthProvider() from the server but AuthProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/provider/auth.tsx <module evaluation>\",\n    \"AuthProvider\",\n);\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,cAAc,CAAA,GAAA,yMAAA,CAAA,0BAAuB,AAAD,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAsO,GACnQ,mDACA;AAEG,MAAM,eAAe,CAAA,GAAA,yMAAA,CAAA,0BAAuB,AAAD,EAC9C;IAAa,MAAM,IAAI,MAAM;AAAwO,GACrQ,mDACA"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/provider/auth.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const AuthContext = registerClientReference(\n    function() { throw new Error(\"Attempted to call AuthContext() from the server but AuthContext is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/provider/auth.tsx\",\n    \"AuthContext\",\n);\nexport const AuthProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call AuthProvider() from the server but AuthProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/provider/auth.tsx\",\n    \"AuthProvider\",\n);\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,cAAc,CAAA,GAAA,yMAAA,CAAA,0BAAuB,AAAD,EAC7C;IAAa,MAAM,IAAI,MAAM;AAAsO,GACnQ,+BACA;AAEG,MAAM,eAAe,CAAA,GAAA,yMAAA,CAAA,0BAAuB,AAAD,EAC9C;IAAa,MAAM,IAAI,MAAM;AAAwO,GACrQ,+BACA"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["// Next\r\nimport { NextResponse } from \"next/server\";\r\nimport type { NextRequest } from \"next/server\";\r\n\r\nimport { RegraUsuario, podeAcessarRota } from \"./utils/checkRule\";\r\nimport { useContext } from \"react\";\r\nimport { AuthContext } from \"./provider/auth\";\r\n\r\n// Routes that require authentication\r\nconst rotasProtegidas = [\"/dashboard\", \"/catalogo\", \"/dono\"];\r\n\r\nfunction isProtectedRoute(pathname: string): boolean {\r\n  return rotasProtegidas.some((rota) => pathname.startsWith(rota));\r\n}\r\n\r\nfunction redirectTo(path: string, request: NextRequest) {\r\n  return NextResponse.redirect(new URL(path, request.url));\r\n}\r\n\r\nexport function middleware(request: NextRequest) {\r\n  const token = request.cookies.get(\"auth_token\")?.value;\r\n  const userRule = request.cookies.get(\"user_rule\")?.value as RegraUsuario;\r\n\r\n  const { user } = useContext(AuthContext);\r\n\r\n  const pathname = request.nextUrl.pathname;\r\n  const protegido = isProtectedRoute(pathname);\r\n\r\n  // No token or rule => redirect if protected route\r\n  if (!token || !userRule) {\r\n    return protegido ? redirectTo(\"/signin\", request) : NextResponse.next();\r\n  }\r\n\r\n  // Already have token and try to access /signin => redirect to area\r\n  if (pathname === \"/signin\") {\r\n    let redirectPath = \"/catalogo\";\r\n\r\n    switch (userRule) {\r\n      case RegraUsuario.admin:\r\n      case RegraUsuario.dono:\r\n      case RegraUsuario.suportedosistema:\r\n        redirectPath = \"/dashboard\";\r\n        break;\r\n      case RegraUsuario.cliente:\r\n        redirectPath = \"/catalogo\";\r\n        break;\r\n      case RegraUsuario.estoque:\r\n        redirectPath = \"/estoque\";\r\n        break;\r\n    }\r\n\r\n    return redirectTo(redirectPath, request);\r\n  }\r\n\r\n  // If route is protected and user cannot access\r\n  const podeAcessar = podeAcessarRota(userRule, pathname);\r\n  if (protegido && !podeAcessar) {\r\n    return redirectTo(\"/forbidden\", request);\r\n  }\r\n\r\n  return NextResponse.next();\r\n}\r\nexport const config = {\r\n  matcher: [\"/dashboard/:path*\", \"/catalogo/:path*\", \"/dono/:path*\", \"/signin\"],\r\n};\r\n"],"names":[],"mappings":"AAAA,OAAO;;;;;AACP;AAAA;AAGA;AACA;AACA;;;;;AAEA,qCAAqC;AACrC,MAAM,kBAAkB;IAAC;IAAc;IAAa;CAAQ;AAE5D,SAAS,iBAAiB,QAAgB;IACxC,OAAO,gBAAgB,IAAI,CAAC,CAAC,OAAS,SAAS,UAAU,CAAC;AAC5D;AAEA,SAAS,WAAW,IAAY,EAAE,OAAoB;IACpD,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,MAAM,QAAQ,GAAG;AACxD;AAEO,SAAS,WAAW,OAAoB;IAC7C,MAAM,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,eAAe;IACjD,MAAM,WAAW,QAAQ,OAAO,CAAC,GAAG,CAAC,cAAc;IAEnD,MAAM,EAAE,IAAI,EAAE,GAAG,CAAA,GAAA,qLAAA,CAAA,aAAU,AAAD,EAAE,yHAAA,CAAA,cAAW;IAEvC,MAAM,WAAW,QAAQ,OAAO,CAAC,QAAQ;IACzC,MAAM,YAAY,iBAAiB;IAEnC,kDAAkD;IAClD,IAAI,CAAC,SAAS,CAAC,UAAU;QACvB,OAAO,YAAY,WAAW,WAAW,WAAW,6LAAA,CAAA,eAAY,CAAC,IAAI;IACvE;IAEA,mEAAmE;IACnE,IAAI,aAAa,WAAW;QAC1B,IAAI,eAAe;QAEnB,OAAQ;YACN,KAAK,0HAAA,CAAA,eAAY,CAAC,KAAK;YACvB,KAAK,0HAAA,CAAA,eAAY,CAAC,IAAI;YACtB,KAAK,0HAAA,CAAA,eAAY,CAAC,gBAAgB;gBAChC,eAAe;gBACf;YACF,KAAK,0HAAA,CAAA,eAAY,CAAC,OAAO;gBACvB,eAAe;gBACf;YACF,KAAK,0HAAA,CAAA,eAAY,CAAC,OAAO;gBACvB,eAAe;gBACf;QACJ;QAEA,OAAO,WAAW,cAAc;IAClC;IAEA,+CAA+C;IAC/C,MAAM,cAAc,CAAA,GAAA,0HAAA,CAAA,kBAAe,AAAD,EAAE,UAAU;IAC9C,IAAI,aAAa,CAAC,aAAa;QAC7B,OAAO,WAAW,cAAc;IAClC;IAEA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AACO,MAAM,SAAS;IACpB,SAAS;QAAC;QAAqB;QAAoB;QAAgB;KAAU;AAC/E"}}]
}