{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/utils/checkRule.ts"],"sourcesContent":["export enum RegraUsuario {\n  admin = \"admin\",\n  dono = \"Dono\",\n  estoque = \"estoque\",\n  suportedosistema = \"suporte do sistema\",\n  cliente = \"cliente\",\n}\n\n// Check if the user has special permission  (admin, dono, suporte)\nexport function checkRule(regra: RegraUsuario): boolean {\n  const permissoesEspeciais = new Set([\n    RegraUsuario.admin,\n    RegraUsuario.dono,\n    RegraUsuario.suportedosistema,\n  ]);\n\n  return permissoesEspeciais.has(regra);\n}\n\n// Check if the user is a client\nexport function isCliente(regra: RegraUsuario): boolean {\n  return regra === RegraUsuario.cliente;\n}\n\n// Check if the user can access a route in the rule and path\nexport function podeAcessarRota(regra: RegraUsuario, path: string): boolean {\n  if (checkRule(regra)) {\n    return true;\n  }\n\n  if (isCliente(regra)) {\n    const permitido = path.startsWith(\"/catalogo\");\n    return permitido;\n  }\n\n  return false;\n}\n"],"names":[],"mappings":";;;;;;AAAO,IAAA,AAAK,sCAAA;;;;;;WAAA;;AASL,SAAS,UAAU,KAAmB;IAC3C,MAAM,sBAAsB,IAAI,IAAI;;;;KAInC;IAED,OAAO,oBAAoB,GAAG,CAAC;AACjC;AAGO,SAAS,UAAU,KAAmB;IAC3C,OAAO;AACT;AAGO,SAAS,gBAAgB,KAAmB,EAAE,IAAY;IAC/D,IAAI,UAAU,QAAQ;QACpB,OAAO;IACT;IAEA,IAAI,UAAU,QAAQ;QACpB,MAAM,YAAY,KAAK,UAAU,CAAC;QAClC,OAAO;IACT;IAEA,OAAO;AACT"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/middleware.ts"],"sourcesContent":["// Next\nimport { NextResponse } from \"next/server\";\nimport type { NextRequest } from \"next/server\";\n\nimport { RegraUsuario, podeAcessarRota } from \"./utils/checkRule\";\n\n// Routes that require authentication\nconst rotasProtegidas = [\"/dashboard\", \"/catalogo\", \"/dono\"];\n\nfunction isProtectedRoute(pathname: string): boolean {\n  return rotasProtegidas.some((rota) => pathname.startsWith(rota));\n}\n\nfunction redirectTo(path: string, request: NextRequest) {\n  return NextResponse.redirect(new URL(path, request.url));\n}\n\nfunction parseUserRule(raw?: string): RegraUsuario | undefined {\n  if (!raw) return undefined;\n\n  try {\n    let normalized = decodeURIComponent(raw);\n    normalized = normalized.trim().toLowerCase();\n\n    normalized = normalized.replace(/[\\s\\-_]+/g, \"\");\n\n    normalized = normalized.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n\n    const map: Record<string, RegraUsuario> = {\n      admin: RegraUsuario.admin,\n      dono: RegraUsuario.dono,\n      suportedosistema: RegraUsuario.suportedosistema,\n      cliente: RegraUsuario.cliente,\n      estoque: RegraUsuario.estoque,\n    };\n\n    return map[normalized];\n  } catch (e) {\n    return undefined;\n  }\n}\n\nexport function middleware(request: NextRequest) {\n  const token = request.cookies.get(\"auth_token\")?.value;\n  const cookieRule = request.cookies.get(\"user_rule\")?.value as RegraUsuario;\n  const userRule = parseUserRule(cookieRule);\n\n  const pathname = request.nextUrl.pathname;\n  const protegido = isProtectedRoute(pathname);\n\n  if (!token || !userRule) {\n    return protegido ? redirectTo(\"/signin\", request) : NextResponse.next();\n  }\n\n  if (pathname === \"/signin\") {\n    let redirectPath = \"/catalogo\";\n\n    switch (userRule) {\n      case RegraUsuario.admin:\n      case RegraUsuario.dono:\n      case RegraUsuario.suportedosistema:\n        redirectPath = \"/dashboard\";\n        break;\n      case RegraUsuario.cliente:\n        redirectPath = \"/catalogo\";\n        break;\n      case RegraUsuario.estoque:\n        redirectPath = \"/estoque\";\n        break;\n    }\n\n    return redirectTo(redirectPath, request);\n  }\n\n  const podeAcessar = podeAcessarRota(userRule, pathname);\n  if (protegido && !podeAcessar) {\n    return redirectTo(\"/forbidden\", request);\n  }\n\n  return NextResponse.next();\n}\nexport const config = {\n  matcher: [\"/dashboard/:path*\", \"/catalogo/:path*\", \"/dono/:path*\", \"/signin\"],\n};\n"],"names":[],"mappings":"AAAA,OAAO;;;;;AACP;AAAA;AAGA;;;AAEA,qCAAqC;AACrC,MAAM,kBAAkB;IAAC;IAAc;IAAa;CAAQ;AAE5D,SAAS,iBAAiB,QAAgB;IACxC,OAAO,gBAAgB,IAAI,CAAC,CAAC,OAAS,SAAS,UAAU,CAAC;AAC5D;AAEA,SAAS,WAAW,IAAY,EAAE,OAAoB;IACpD,OAAO,6LAAA,CAAA,eAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,MAAM,QAAQ,GAAG;AACxD;AAEA,SAAS,cAAc,GAAY;IACjC,IAAI,CAAC,KAAK,OAAO;IAEjB,IAAI;QACF,IAAI,aAAa,mBAAmB;QACpC,aAAa,WAAW,IAAI,GAAG,WAAW;QAE1C,aAAa,WAAW,OAAO,CAAC,aAAa;QAE7C,aAAa,WAAW,SAAS,CAAC,OAAO,OAAO,CAAC,oBAAoB;QAErE,MAAM,MAAoC;YACxC,OAAO,0HAAA,CAAA,eAAY,CAAC,KAAK;YACzB,MAAM,0HAAA,CAAA,eAAY,CAAC,IAAI;YACvB,kBAAkB,0HAAA,CAAA,eAAY,CAAC,gBAAgB;YAC/C,SAAS,0HAAA,CAAA,eAAY,CAAC,OAAO;YAC7B,SAAS,0HAAA,CAAA,eAAY,CAAC,OAAO;QAC/B;QAEA,OAAO,GAAG,CAAC,WAAW;IACxB,EAAE,OAAO,GAAG;QACV,OAAO;IACT;AACF;AAEO,SAAS,WAAW,OAAoB;IAC7C,MAAM,QAAQ,QAAQ,OAAO,CAAC,GAAG,CAAC,eAAe;IACjD,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC,cAAc;IACrD,MAAM,WAAW,cAAc;IAE/B,MAAM,WAAW,QAAQ,OAAO,CAAC,QAAQ;IACzC,MAAM,YAAY,iBAAiB;IAEnC,IAAI,CAAC,SAAS,CAAC,UAAU;QACvB,OAAO,YAAY,WAAW,WAAW,WAAW,6LAAA,CAAA,eAAY,CAAC,IAAI;IACvE;IAEA,IAAI,aAAa,WAAW;QAC1B,IAAI,eAAe;QAEnB,OAAQ;YACN,KAAK,0HAAA,CAAA,eAAY,CAAC,KAAK;YACvB,KAAK,0HAAA,CAAA,eAAY,CAAC,IAAI;YACtB,KAAK,0HAAA,CAAA,eAAY,CAAC,gBAAgB;gBAChC,eAAe;gBACf;YACF,KAAK,0HAAA,CAAA,eAAY,CAAC,OAAO;gBACvB,eAAe;gBACf;YACF,KAAK,0HAAA,CAAA,eAAY,CAAC,OAAO;gBACvB,eAAe;gBACf;QACJ;QAEA,OAAO,WAAW,cAAc;IAClC;IAEA,MAAM,cAAc,CAAA,GAAA,0HAAA,CAAA,kBAAe,AAAD,EAAE,UAAU;IAC9C,IAAI,aAAa,CAAC,aAAa;QAC7B,OAAO,WAAW,cAAc;IAClC;IAEA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AACO,MAAM,SAAS;IACpB,SAAS;QAAC;QAAqB;QAAoB;QAAgB;KAAU;AAC/E"}}]
}